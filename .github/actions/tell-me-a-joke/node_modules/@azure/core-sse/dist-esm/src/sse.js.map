{"version":3,"file":"sse.js","sourceRoot":"","sources":["../../src/sse.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nconst enum ControlChars {\n  NewLine = 10,\n  CarriageReturn = 13,\n  Space = 32,\n  Colon = 58,\n}\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\nexport interface EventMessage {\n  /** The event ID to set the EventSource object's last event ID value. */\n  id: string;\n  /** A string identifying the type of event described. */\n  event: string;\n  /** The event data */\n  data: string;\n  /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n  retry?: number;\n}\n\ntype PartialSome<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\n/**\n * Processes a response stream into a stream of events.\n * @param chunkIter - A stream of Uint8Array chunks\n * @returns An async iterable of EventMessage objects\n */\nexport function iterateSseStream(\n  chunkIter: ReadableStream<Uint8Array>\n): AsyncIterable<EventMessage>;\n/**\n * Processes a response stream into a stream of events.\n * @param chunkIter - An async iterable of Uint8Array chunks\n * @returns An async iterable of EventMessage objects\n */\nexport function iterateSseStream(chunkIter: AsyncIterable<Uint8Array>): AsyncIterable<EventMessage>;\nexport function iterateSseStream(\n  chunkIter: AsyncIterable<Uint8Array> | ReadableStream<Uint8Array>\n): AsyncIterable<EventMessage> {\n  return toMessage(toLine(ensureAsyncIterable(chunkIter)));\n}\n\nfunction ensureAsyncIterable(\n  chunkIter: AsyncIterable<Uint8Array> | ReadableStream<Uint8Array>\n): AsyncIterable<Uint8Array> {\n  return isReadableStream(chunkIter) && (chunkIter as any)[Symbol.asyncIterator] === undefined\n    ? toAsyncIterable(chunkIter)\n    : (chunkIter as AsyncIterable<Uint8Array>);\n}\n\nfunction isReadableStream(body: unknown): body is ReadableStream {\n  return Boolean(\n    body &&\n      typeof (body as ReadableStream).getReader === \"function\" &&\n      typeof (body as ReadableStream).tee === \"function\"\n  );\n}\n\nasync function* toAsyncIterable<T>(stream: ReadableStream<T>): AsyncIterable<T> {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { value, done } = await reader.read();\n      if (done) {\n        return;\n      }\n      yield value;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nfunction concatBuffer(a: Uint8Array, b: Uint8Array): Uint8Array {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\n\nfunction createMessage(): PartialSome<EventMessage, \"data\"> {\n  return {\n    data: undefined,\n    event: \"\",\n    id: \"\",\n    retry: undefined,\n  };\n}\n\nasync function* toLine(\n  chunkIter: AsyncIterable<Uint8Array>\n): AsyncIterable<{ line: Uint8Array; fieldLen: number }> {\n  let buf: Uint8Array | undefined;\n  let bufIdx = 0;\n  let fieldLen = -1;\n  let discardTrailingNewline = false;\n  for await (const chunk of chunkIter) {\n    if (buf === undefined) {\n      buf = chunk;\n      bufIdx = 0;\n      fieldLen = -1;\n    } else {\n      buf = concatBuffer(buf, chunk);\n    }\n    const bufLen = buf.length;\n    let start = 0;\n    while (bufIdx < bufLen) {\n      if (discardTrailingNewline) {\n        if (buf[bufIdx] === ControlChars.NewLine) {\n          start = ++bufIdx;\n        }\n        discardTrailingNewline = false;\n      }\n      let end = -1;\n      for (; bufIdx < bufLen && end === -1; ++bufIdx) {\n        switch (buf[bufIdx]) {\n          case ControlChars.Colon:\n            if (fieldLen === -1) {\n              fieldLen = bufIdx - start;\n            }\n            break;\n          case ControlChars.CarriageReturn:\n            // We need to discard the trailing newline if any but can't do\n            // that now because we need to dispatch the current line first.\n            discardTrailingNewline = true;\n            end = bufIdx;\n            break;\n          case ControlChars.NewLine:\n            end = bufIdx;\n            break;\n        }\n      }\n      if (end === -1) {\n        // We reached the end of the buffer but the line hasn't ended.\n        // Wait for the next chunk and then continue parsing:\n        break;\n      }\n      yield { line: buf.subarray(start, end), fieldLen };\n      start = bufIdx; // we're now on the next line\n      fieldLen = -1;\n    }\n    if (start === bufLen) {\n      buf = undefined;\n    } else if (start !== 0) {\n      // discard already processed lines\n      buf = buf.subarray(start);\n      bufIdx -= start;\n    }\n  }\n}\n\nasync function* toMessage(\n  lineIter: AsyncIterable<{ line: Uint8Array; fieldLen: number }>\n): AsyncIterable<EventMessage> {\n  let message = createMessage();\n  const decoder = new TextDecoder();\n  for await (const { line, fieldLen } of lineIter) {\n    if (line.length === 0 && message.data !== undefined) {\n      // empty line denotes end of message. Yield and start a new message:\n      yield message as EventMessage;\n      message = createMessage();\n    } else if (fieldLen > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLen));\n      const valueOffset = fieldLen + (line[fieldLen + 1] === ControlChars.Space ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n\n      switch (field) {\n        case \"data\":\n          message.data = message.data ? message.data + \"\\n\" + value : value;\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          message.id = value;\n          break;\n        case \"retry\": {\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            message.retry = retry;\n          }\n          break;\n        }\n      }\n    }\n  }\n}\n"]}